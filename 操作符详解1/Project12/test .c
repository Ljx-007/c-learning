#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//操作符详解
// 单目操作符 !(逻辑反操作) + - & sizeof ~(二进制按位取反) -- ++ *(解引用) (类型)（强制类型转换）
int main()
{
	/*int a = 1;
	int b = !a;*///逻辑反操作即a不等于0为真，反操作后为假，b=0。a=0时反操作后为真b=1.
	int arr[10] = { 0 };
	printf("%d", sizeof(int[10]));//数组的类型就是把数组名去掉剩下的就是数组类型，如int [10]
	return 0;
}


//练习：编写代码实现：求一个整数在内存中的二进制中1的个数
//方法二：
//int main()
//{
//	int a,count=0;
//	printf("输入一个数求二进制中1的个数：");
//	scanf("%d", &a);
	//要得到二进制中1的个数，让该数字和1按位与
	//00000000000000000000000000000011
	//00000000000000000000000000000001
	//数字和1按位与后若最低位为0，则最低位按位与结果为0，若最低位为1，则按位与结果为1
	//按位与后将数字向右移动1位，将原来的倒数第二位变成最低位，继续用按位与来检测其是否为1	
//	for (int i = 0; i < 32; i++)
//	{
//		if ((a & 1)== 1)
//			count++;
//		a = a >> 1;//或a>>=1
//	}
//	printf("二进制中1的个数为：%d", count);
//	return 0;
//}

//方法一：
//int main()
//{
//	int a,count=0;
//	printf("输入一个数求二进制中1的个数：");
//	scanf("%d", &a);
//	//讲递归函数时曾讲过打印数字，十进制的数字对10取模时能得到最后一位数字，接着除10再取模能得到倒数第二位数字
//	//如1234%10=4，1234/10=123，123%10=3....
//	//同理，求二进制中1的个数可以让这个数字对2取模，得到的结果就是1或者0
//	//如6的二进制为110，对2取模得到二进制的最后一位数字0，除2后再取模得到1，以此类推能得出二进制中1的个数
//	while (a)//a会一直除2直到商为0，即已经遍历到了a的第一位数字，此时循环结束
//	{
//		if (a % 2 == 1)//这个算法有一个问题，算不了负数，所以采取别的办法。
//			count++;
//		a=a / 2;
//	}
//	printf("二进制中1的个数为：%d", count);
//	return 0;
//}

//位操作符：&--按位与，|--按位或，^--按位异或 .他们的操作数必须是整数

//交换变量且不能使用第三个变量，可以利用异或交换两个变量值
//int main()
//{
//	int a = 3, b = 5;
//	printf("a=%d,b=%d\n", a, b);
//	a = a ^ b;//3^5相当于一个密码，这个密码再次与3异或的时候翻译出来是5，与5异或的时候翻译出来是3
//	b = a ^ b;//可以看成是一个解码的过程
//	a = a ^ b;
//	printf("a=%d,b=%d", a, b);
//	return 0;
//}


//int main()
//{
//	//&--按位与（二进制位）,两个二进制位有一个为0就为0，两个同时为1才为1
//	int a = 3, b = 5;//3--011
//	int c = a & b;   //5--101
//	             //3&5=1--001
//	//|--按位或（二进制位），两个二进制位有一个为1就为1，两个同时为0才为0
//	int x = 3, y = 5; //3--011
//	int z = x | y;    //5--101
//	              //3|5=7--111
//	//^--按位异或（二进制位），两个二进制位相同为0，相异为1
//	int i = 3, j = 5;//3--011
//	int k = i ^ j;   //5--101
//	             //3^5=6--110
//	return 0;
//}



//左移，右移操作符  <<,>>   对于移动操作符，不要移动负数位，这是没有定义的
//移动操作符只能作用于整数
//int main()
//{  //左移操作符：左边丢弃，右边补0.  （区别于右移，只有一种）
//	int a = 10;
//	int b = a << 1;//左移1位相当于乘2，右移1位相当于除2
//	printf("%d", b);
//	return 0;
//}

//int main()
//{  //右移操作符：>>
	//int a = -1;
	//右移分为两种：1、算术右移   2、逻辑右移
	//算术右移：右边丢弃，左边补原符号位（原来是正数就补0，原来是负数就补1）
	//逻辑右移：右边丢弃，左边补0
/*	int b = a >> 1;
	printf("%d\n", b);*///将b打印出来结果为-1，可知一般的移位为算术移位.
	//负数在电脑中以补码形式存储，-1的原码为10000000000000000000000000000001，补码为从右数起第一个1后除符号位按位取反
	//则-1的补码为11111111111111111111111111111111
	//补码向右移动1位左边补1仍是11111111111111111111111111111111
	//再转化为原码从右数第一个1后除符号位按位取反变为10000000000000000000000000000001，所以-1右移一位还是-1
//	int c = 16;
//	int d = c >> 2;//右移两位也是一样的,结果为4,可知右移1位有除2的效果。假设c=18，右移1位结果为9
//	printf("%d\n", d);
//	return 0;
//
//}


//运算操作符：+ - * / % 
//int main()
//{
//	int a = 5 / 2;//整数除法只能算出整数，浮点数除法才能算出小数，如果想得到小数，则5和2其中一个必须为浮点型
//	int b = 5 % 2;//取模%运算左右两边都只能是整数，返回的是整除之后的余数
//	printf("%d\n", a);//除法算出来的a只有整数部分，即商部分，a=2
//	return 0;
//}