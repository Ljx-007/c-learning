#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>

//下面程序运行的结果是？
//unsigned char i = 0;//无符号char型的范围是0-255，所以for循环永远满足条件，故死循环
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}



//下面程序运行的结果是？
//int main()
//{
//	char a[1000];//char的取值范围为-128 -> 127，当存放到char类型的数字超过这个范围时，就会被转化为这个范围里面的数字
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//i的遍历从0-999，-1-i的遍历就是-1到-1000，而char在负数中最低只能存放-128
//		//所以-1，-2，-3,....,-128,-129  遍历到-129时，-129=-128-1，在二进制中表示为10000000-00000001=01111111--127
//		//所以-129被转化为127，同理-130被转化为126，以此类推，放入char a中的值其实是：
//		//-1，-2-，3，....，-128，127，126，125，...，3，2，1，0
//		//最后0对应的字符就是'\0'，字符串以\0为结束标志，最终strlen(a)的结果是255，负数有128个，正数有127个，127+128=255
//	}
//	printf("%d", strlen(a));
//	return 0;
//}



//下面程序运行的结果是？
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);//一直死循环，i是无符号数，不可能为0	
//	}
//	return 0;
//}



//下面程序运行的结果是？
//int main()
//{
//	int a = -20; 
//	//10000000000000000000000000010100--原码
//	//11111111111111111111111111101100--补码
//	unsigned int b = 10;
//	//00000000000000000000000000001010--原反补码
//	//a+b
//	//11111111111111111111111111101100-- -20
//	//00000000000000000000000000001010-- 10
//	//11111111111111111111111111110110--补码相加的结果
//	//转原码：10000000000000000000000000001010-- -10
//	printf("%d", a + b);//所以结果为-10
//	return 0;
//}