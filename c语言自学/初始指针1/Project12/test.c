#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//野指针:指针指向的位置不可知（随机的，不正确的，没有明确限制的）
//野指针成因3：指针指向的空间释放
int* test()//返回的是一个地址，所以函数类型是指针类型
{
	int a = 10;
	return &a;
}
int main()
{
	int* p=test();//p接收了a的地址，假设为0x0011ff44
	*p = 20;//a是局部变量，出了函数之后就被销毁了，所以地址所在的空间也被释放，此时该地址的空间有可能被别人占用了
	//通过*p找到的空间已经不存在a，此时p就是一个野指针
	return 0;
}


//int main()
//{
	//野指针成因：1、指针未初始化
	//int* p;//局部变量指针未初始化，默认为随机值
	//*p = 0; //地址随机，即在内存中随便找一个地址存放0
	//野指针成因：2、指针越界访问
//	int arr[10] = { 0 };
//	int* p = arr;//数组名--首元素地址 
//	for (int i = 0; i < 12; i++)
//	{
//		p++;//数组元素的地址一共就10个，这里遍历了12次，指针指向的范围超越了数组arr的范围，即越界访问，不知道访问到哪里去，也是野指针
//	}
//	return 0;
//}



//int main()
//{
//	int a = 0x11223344;
//	int* pa = &a;
//	char* pc = &a;
//	//指针类型决定了指针+1向后跳几个字节（决定了指针的步长）
//	printf("%p\n", pa);
//	printf("%p\n", pa+1);  //int是整型4个字节，所以int*类型的指针+1时跳过的是一个整型也就是4个字节
//	printf("%p\n", pc);
//	printf("%p\n", pc+1); //char是字符类型1个字节，所以char*类型的指针+1时跳过的是一个字符也就是1个字节
//	return 0;
	//int* p:p+1-->4个字节
	//char* p:p+1-->1个字节 
	//double* p:p+1-->8个字节
//}




//int main()
//{
//	int a = 0x11223344;//十六进制四个字节，在内存中存放为44 33 22 11
//	int* pa = &a;
	//char* pc = &a;//两种不同类型的指针都能存放a的地址
	*pa = 0;//区别在于进行解引用操作时int*类型能修改4个字节内容，将a变为00 00 00 00
//	*pc = 0; //char*类型只能修改一个字节的内容，将a变为00 33 22 11
//	return 0;
	//指针类型决定了指针进行解引用操作时，能够访问空间的大小
	//int* p，能够访问4个字节
	//char* p，能够访问1个字节
	//double* p，能够访问8个字节
//}