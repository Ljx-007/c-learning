#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
int main()
{
	//重新回到这串代码，我们来解释一下
	int n = 9;
	//00000000000000000000000000001001--补码
	//对于浮点数的存储来说，32位被分为
	//0 00000000 00000000000000000001001
	//S    E              M
	//表示E的二进制位全0，当全0的时候不需要补1，直接补0，E二进制全0时，规定E=1-127，表示0或者非常接近0的数
	//所以还原出来的浮点数为：(-1)*0 * 0.00000000000000000001001 * 2^-126  这个数字非常接近0，所以打印出来为0.000000
	float* pfloat = (float*)&n;
	printf("n=%d\n", n);//9
	printf("*pfloat=%f\n", *pfloat);//0.000000
	*pfloat = 9.0;
	//9.0作为浮点数二进制为1001.0，可以写成(-1)*0 *1.001 * 2^3
	// E=3+127=130,二进制位为10000011
	//存储到内存中为0 10000011 00100000000000000000000
	//              S    E            M
	//打印n时当成整型作为补码打印出来结果就是1091567616
	printf("n=%d\n", n);//1091567616
	printf("*pfloat=%f\n", *pfloat);//9.000000
	return 0;
}

//对于E来说，由于科学计数法的指数可以出现负值，而计算机里规定E是一个无符号整数，无符号数无负值，所以为了让E成为无符号数，E要加一个中间值
//对于32位浮点数来说，中间数为127。对于64位浮点数来说，中间数为1023。当要从内存中取出E时，再减去这个中间值即可


//对于M来说，由于M总是大于等于1，即是1.xxxxxx的形式，第一位总是1，所以计算机存储M时，可以舍弃这个1，只保存后面的xxxxx部分
//比如保存1.01时，只保存01，等到读取的时候，再把第一位的1加上去，但当E二进制为全0时，直接补0不补1
//这样做的目的是节省1位有效数字，以32位浮点数为例，留给M只有23位，将第一位的1舍去后，可以保留24位有效数字


//对于32位（单精度浮点型）浮点数来说，最高的一位是符号位S，接着的8位数是E，剩下的23位为有效数字M
//对于64位（双精度浮点型）浮点数来说，最高的一位是符号位S，接着的11位数是E，剩下的52位为有效数字M


//根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：
//( -1)^S * M *2^E  -- -1的S次方乘M乘2的E次方
// (-1)^S表示符号位，当S=0，V为正数，S=1，V为负数
// M表示有效数字，大于等于1，小于2--因为二进制数遇2进1，所以小于2
// 2^E表示指数位
//例如9.0
//二进制表示为1001.0
//可以写成
//(-1)^0 * 1.001 * 2^3
//(-1)^S * M     * 2^E
//所以，当我们要存储浮点数时，只需要知道它的S,M,E存储起来，需要用时再拿出来就好了

//int main()
//{
//	int n = 9;
//	float* pfloat = (float*)&n;
//	printf("n=%d\n", n);//9
//	printf("*pfloat=%f\n", *pfloat);//0.000000
//	*pfloat = 9.0;
//	//整型和浮点型在内存都存储四个字节，但是用指针存地址时和解引用后打印出来的结果却完全不同，这是因为整型和浮点型在内存中的存储方式不同
//	printf("n=%d\n", n);//1091567616
//	printf("*pfloat=%f\n", *pfloat);//9.000000
//	return 0;
//}