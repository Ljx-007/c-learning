#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//枚举--他是一个类型，可以通过这个类型创建变量
//枚举的定义--顾名思义就是把可能的值一一列举
//enum day   //枚举的创建用enum
////例如星期，就把已有的星期一一列举出来
//{
//	Mon,
//	Tues,
//	Wed,      //Day是枚举类型，里面放的是枚举的可能取值,之间用逗号隔开
//	Thur,
//	Fri,
//	Sat,
//	Sun
//};
//enum Color
//{
//	RED, //0
//	GREEN,//1     //枚举的可能取值也叫枚举常量
//	BLUE//2      枚举的大小为4，因为存放的是整型
//};
//enum Sex
//{
//	//如果我们不想让MALE,FEMALE,SECRET的值为0，1，2，我们也可以修改
//	MALE=2,
//	FEMALE=4,   //这里并不是修改枚举常量，而是给常量赋一个初始值
//	           //如果没有赋初始值，那么枚举常量的值将会顺延上一个枚举常量的值，如FEMALE不赋值，MALE=2，那么FEMALE就等于3a
//	SECRET=8
//};
//
////我们可以使用#define来定义常量，为什么非要使用枚举？枚举的优点：
////1.增加代码的可读性和可维护性
////2.和#define定义的标识符比较，枚举有类型检查，更严谨
////3.防止了命名的污染
////4.便于调试
////5.使用方便，一次可以定义多个常量
//
//int main()
//{
//	enum Sex s = MALE;
//	//enum Color c = BLUE; 这里将BLUE赋给了变量c，BLUE的值为2，那么能不能直接给c赋值2呢？
//	enum Color c = 2; //这里编译器没有报错并不代表这样的写法是对的
//	//因为2的类型是int，而c的类型是enum Color,不能直接赋值
//	//如果在C++里来编译，那么就会报错，所以不能这样写
//	//打印枚举常量
//	printf("%d %d %d\n", RED, GREEN, BLUE);//0,1,2
//	printf("%d %d %d\n", MALE, FEMALE, SECRET);//2,4,8
//	return 0;
//}



//联合（联合体/共用体）
//联合也是一种特殊的自定义类型，这种类型定义的变量也包含一系列成员，特征是这些成员共用一块空间（所以联合也叫共用体）
//union Un   //联合体的创建用union
//{
//	char c;
//	int i;
//};
//联合的成员是共用一块空间的，这样一个联合变量的大小，至少是最大成员的大小。因为联合至少得有能力保存最大的那个成员
//因为联合体的成员内存空间是共用的，所以不能在同一时刻使用多个成员，因为改了其中一个另外一个就改了
//int main()
//{
//	union Un u;
//	printf("%d\n", sizeof(u));//4
	//我们打印联合变量u和u内的成员c，i时会发现，他们三个的地址都是一样的
	//这是因为在联合体中，联合体的成员是共用一块内存
	//以联合体Un举例，开辟内存空间时，先申请一块int大小的空间存放c，放完c后还有一个i，直接把这个i也放在这个int大小的空间内
	//所以联合体和联合体成员的地址都是相同的，且打印出的联合变量u的大小是4个字节
//	printf("%p\n", &u);
//	printf("%p\n", &(u.c));
//	printf("%p\n", &(u.i));
//	return 0;
//}

//面试题：判断大小端
//重新回忆大小端的存储结构
//int a=0x11 22 33 44
//低地址------------------------->高地址
//小端存储：   44 33 22 11  （低位放在低地址，高位放在高地址）
//大端存储：   11 22 33 44  （低位放在高地址，高位放在低地址）
//如果要写一个程序判断大小端，那我们只需要判断第一个字节的内容是44还是11即可，我们重新用一个简单的数字
//int a=1  在内存存储当中，a=0x00 00 00 01
//小端存储：  01 00 00 00     大端存储： 00 00 00 01
//只需要拿出第一个字节的内容判断是否为0或者1即可，对&a强制类型转化为char*来访问一个字节，如果为0就是大端，如果为1就是小端
//现在学了联合体，可以考虑使用联合体的知识来解决
//union Un
//{
//	char c;    //因为c和i共用一块空间，且这块空间大小为4个字节
//	int i;     //内存空间如下所示： （00） 00 00 00   括号括起来的一个字节就是c的内容，整一个是i的内容
//	   //c代表了这块空间第一个字节的内容，那么正好与之前判断大小端需要拿出来的第一个字节吻合
//	  //所以我们直接令i=1，判断c是0还是1即可判断出大小端
//};
//以下是程序实现：
//int check_sys()
//{
//	union Un  //这里也可以把Un省略掉，变成匿名联合体，因为也只使用一次，只创建一次联合变量u
//	{
//		char c;
//		int i;
//	}u;
//	u.i = 1;
//	//返回1，小端
//	//返回0，大端
//	return u.c;
//}
//int main()
//{
//	int ret=check_sys();
//	if (1 == ret)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}

//联合体大小的计算
//联合体的大小至少是最大成员的大小
//当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍
union Un
{
	int a; //对齐数是4
	char arr[5]; //算数组的对齐数时，看数组的元素的类型，用数组元素的类型来计算对齐数，所以用char类型。char arr[5]相当于在联合体内写了5个char
	            //所以按1来计算，与默认对齐数8比较，1较小，所以1是该数组的对齐数
	//该联合体的最大对齐数是4，该联合体的最大成员大小是5，5不是最大对齐数4的整数倍，对齐到8，8是4的整数倍，所以8是共用体的大小
};
int main()
{
	union Un u;
	enum Color c;
	printf("%zd", sizeof(u));//8
	return 0;
}