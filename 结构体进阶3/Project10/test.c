#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//结构体传参
//struct S
//{
//	int a;
//	char c;
//	double d;
//};
//void Init(struct S tmp)   直传（传值）的方式不合适
//{
//	tmp.a = 100;
//	tmp.c = 'w';
//	tmp.d = 3.14;
//}

//void Init(struct S* ps)  //传址
//{
//	ps->a = 100;
//	ps->c = 'w';
//	ps->d = 3.14;
//}
//int main()
//{
//	struct S s = { 0 };
//	//Init(s);//当结构体传参时，如果我们直接传值的话，那么函数参数的接收是直接临时拷贝一份s，在函数内修改的结构体变量修改的只是拷贝的那一份
//	//        实际上并没有改变s的值，所以结构体传参时，不应该采用直传的方式，而是要传它的地址。
//	Init(&s); //初始化s的内容
//	return 0;
//}

//位段
//位段是结构体式的一种类型，但与结构体有所区别
//位段的声明和结构是类似的，有两个不同
//1.位段的成员必须是int,unsigned int, signed int  (也可以有char，但是如果出现char，一般全是char) （属于整型家族都可以）
//2.位段的成员名后有一个冒号和一个数字

//位段的位指的是二进制位
//struct S
//{
//	//这里不一定是_a,也可以是a，只是一个名字而已
//	int _a : 2;   //冒号后加一个数字意思是a只需要占2个bit位即可
//	int _b : 5;   //b只用占5个bit位即可
//	int _c : 10;  //c只用占10个bit位
//	int _d : 30;  //d只用占30个bit位
//	//位段的数字如果大于32会报错，因为int型就占32个bit
//};
//一共只需要47个bit位--6个字节就够了,但为什么打印出来大小是8个字节呢？这里涉及到位段的内存分配

//位段的内存分配
//1.位段的空间上是按照需要以4个字节（int）或者1个字节（char）的方式来开辟的
// 2.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段


//处理位段内存分配时，电脑首先给一块int大小的内存空间，也就是32个bit位--4个字节，再把位段中的变量一个一个放入
//a只占2个bit，那么就在这32个bit位中分出两个给a，b占5个bit，再从中分出5个bit给b，c占10个bit，从中分出10个bit给c
//此时32个bit位已经被分配了17个bit了，剩下15个bit，不够放d，因为d要占30个bit，那么电脑会再开辟一份int大小的空间，用来存放d
//前面剩下的15个bit位就被浪费掉了。所以这个位段一共开辟了8个字节的空间，所以打印出来是8
//int main()
//{
//	struct S s;
//	printf("%d", sizeof(s)); //8
//	return 0;
//}

struct S  //如果位段中是char型的变量，那么就一次开辟char型大小的空间，也就是8个bit位--1个字节
{
	char a : 3;
	char b : 4;   //模拟内存空间开辟，先开辟一个字节，放入a--010,在VS底下是从低位向高位使用（从右向左）
	     //开辟的一个字节还剩下5个bit位，还可以存入b，所以放入b--0100 ，剩下1个bit位不够存放c，于是浪费掉，再开辟1个字节内存放c
	   //再开辟的一个字节放入c后还剩下3个bit位，不够存放d，所以再开辟一个字节内存放d
	char c : 5;  //0 | 0 1 0 0 | 0 1 0   0 0 0 | 0 0 0 1 1   0 0 0 0 | 0 1 0 0
	   //至此a,b,c,d已经全部存放进内存中，一共开辟了3个字节，作为检查，将3个字节的二进制位转化为16进制，从调试中的内存查看是否正确
	 // 4个bit位为一个16进制数，所以转化后为 22 03 04 
	//经检验，VS对于位段的内存存放方式确实如分析所示，放入二进制位从低位向高位
	char d : 4; 
};

//位段的跨平台问题
//1.int位段被当成有符号数还是无符号数是不确定的（即开辟出来的int空间最高位是否为符号位是不确定的）
//2.位段中最大位的数目不能确定（16位机器最大16，32位机器最大32，写成27，在16位的机器中会出问题） （16位机器就是把int当成2个字节）
//3.位段中的成员在内存中从左向右分配还是从右向左分配标准尚未定义
//4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是否舍弃剩余的位还是利用，这是不确定的

//位段的应用：数据包的封装

int main()
{
	struct S s = { 0 };
	s.a = 10; //10的二进制位是1010，但a只能放3个bit位，所以要截断，截出010放入内存
	s.b = 20;  //20的二进制位是10100，但b只能放4个bit位，所以截断，截出0100放入内存
	s.c = 3;  //3的二进制位是011，但c要放5个bit位，所以补0，补出00011放入内存
	s.d = 4; //4的二进制位是100，d要放4个bit位，所以补0，补出0100放入内存

	return 0;
}