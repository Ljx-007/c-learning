#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//隐式类型转换：整型提升、算术转换
//算术转换
//long double
//double
//float
//unsigned long int              当两个不同类型的数字进行运算时，类型小的会转化为类型大的类型进行运算
//long int                       如int 和float进行运算时，int会转换为float，再进行计算
//unsigned int 
//int     从int开始越往上大小越大



//整型提升第二例：
//int main()
//{
//	//char类型在进行整型运算时就会进行整型提升
//	char c = 1;
//	//%u打印无符号数字
//	printf("%u\n", sizeof(c));//1   未进行整型运算
//	printf("%u\n", sizeof(+c));//4   +c进行了整型运算，所以整型提升打印出字节为4
//	printf("%u\n", sizeof(!c));//1   未进行整型运算
//	return 0;
//}


//整型提升第一例：
//int main()
//{
//	char a = 3, b = 127, c;
	//3是一个整型，整型在内存占4个字节，二进制为：00000000000000000000000000000011
	//char类型在内存占1个字节，即8个bit,a是char型，所以只能存储8个字节，这时将发生截断，截断3中最低的八位：00000011 - a
	//同理127是整型，在二进制中为：00000000000000000000000001111111
	//在char中只能保存1个字节，发生截断后变为：01111111 - b
	//a,b如何相加，即使两个char类型的相加，在cpu执行时也要先转换为普通整型，这个步骤叫整型提升
	//如何进行整型提升：整型提升是按照变量的数据类型的符号位来提升的，提升为正常整型时，高位补充符号位
	//a进行整型提升，符号位为0，所以提升后高位补充0，结果为00000000000000000000000000000011
	//b进行整型提升，符号位为0，所以提升后高位补充0，结果为00000000000000000000000001111111
	//整型提升后就可以把a和b相加了，结果为                000000000000000000000000010000010
	//相加后的结果放在c中，c为char类型，所以也要进行截断，截断的结果是10000010
	//由于后续打印用的是%d，需要打印一个整型，所以再进行整型提升，高位补充符号位
	//c此时变为11111111111111111111111110000010--补码
   //转换为原码10000000000000000000000001111110--原码，这个原码二进制转化为十进制就是-126
//	c = a + b;
//	printf("%d\n", c);//结果为-126
//	return 0;
//}



//结构体,即创建一种类型,类型是用来创建变量的
//以学生为例，我们创建“学生”这种类型
//struct Stu 
//{
//	char name[20];
//	int age;           //创建的结构体类型相当于是图纸
//	char id[20];
//};
//int main()
//{
//	//使用struct Stu创建了一个学生对象s1，并初始化
//	struct Stu s1 = { "张三",18,"2022101915" };
//	struct Stu* ps = &s1;//创建的结构体变量也有地址，地址的类型依然是类型名加个*
//	//通过地址来打印结构体变量里的成员
//	//->的用法：结构体指针->成员名
//	//.的用法：结构体.成员名
//	printf("%s\n", ps->name);  //可以用->操作符来直接从指针变量里获得成员
//	printf("%s\n", (*ps).name);//也可以先将指针解引用后用.操作符获得成员
//	printf("%s\n", s1.name);//创建的结构体变量相当于是房子，按照图纸来盖房子，即按照结构体设置的变量来填充变量
//	printf("%d\n", s1.age);
//	printf("%s\n", s1.id); 
//	//结构体变量.成员名
//	return 0;
//}



//逗号表达式
//int main()
//{
/*	int a = 1, b = 2;
	int c = (a > b, a = b + 10, a, b = a + 1);*/// 逗号表达式，从左向右依次执行，整个表达式的结果是最后一个表达式的结果
	//c最后的结果为13
	//a = get_val();
	//count_val(a);
	//while (a > 0)
	//{
	//	//业务处理
	//	a = get_val();  //这段代码里有重复的两行代码，略显嗦，可以使用逗号表达式来精简
	//	count_val(a);
	//}
	//精简版本：
	//此处使用了逗号表达式，进入循环时先运行了a = get_val(), count_val(a)，最后表达式的结果为a>0，符合上述代码的循环判断，且没有重复的代码
	//while (a = get_val(), count_val(a), a > 0)  
	//{
	//	//业务处理
	//}
//	return 0;
//}


//条件操作符: exp1 ? exp2 :exp3
//如果表达式1为真,则执行表达式2的内容,如果为假执行表达式3的内容
//int main()
//{
//	int a, b;
//	printf("请输入两个数字比较其大小:");
//	scanf("%d%d", &a, &b);
//	int max = a > b ? a : b;
//	printf("max=%d", max);
//	return 0;
//}



//逻辑与,逻辑或.  && ,||
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
	//i = a++ && ++b && d++;//a++时是先使用再+1,使用时a=0,而逻辑与&&前面有0出现时就不进行后面的运算了,所以b不会+1,d也不会+1
//	i=a++||++b||d++;  //逻辑或的结果是1,3,3,4. 因为逻辑或左边出现一个1后右边的结果无论是什么都为1,所以不会继续进行后面的运算
//	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);//结果abcd分别等于1,2,3,4.
//	return 0;
//}

//int main()
//{
//	int a = 11;//二进制为：00000000000000000000000000001011，要将它的第三位改为1
//	a = a | (1 << 2);//将a按位或上一个向左移动两位的1即可：00000000000000000000000000000100
//	//结果为00000000000000000000000000001111，a=11.
//	//再把a改回去
//	a = a & (~(1 << 2));//即按位与上一个11111111111111111111111111111011,这串二进制数就是1向左移动2位后取反的结果
//	//a=a^(1<<2);  该结果用异或也可以实现
//	return 0;
//}


/*int main()
{
	int a = 0;
	printf("%d", ~a);*///~按二进制位取反，00000000000000000000000000000000
	//取反后变为11111111111111111111111111111111--补码
	//转原码，符号位不变，从右数第一个1后按数值位取反变为10000000000000000000000000000001
	//所以~a=-1


/*	short s = 0;
	int a = 10;
	printf("%d\n", sizeof(s = a + 5));
	printf("%d", s);*///s=0,sizeof里放的表达式是不会实际运行的，也就是说s的值不会被sizeof里面的表达式改变
//	return 0;
//}