#define _CRT_SECURE_NO_WARNINGS 
#include <stdio.h>
//指针
//int main()
//{
//	int a = 10;//如果变量为char ch ='w',则指针变量类型为char*
//	//printf("%p", &a);//&取地址符号，取电脑给a申请的内存空间的地址，打印地址用%p
//	int* p = &a;//用来存放地址的变量叫做指针变量，指针变量的类型是int*
//	*p = 20;//*解引用操作符，对p进行解引用操作，找到p所指的对象a，即通过*p将a的值改为20
//	// 此处*p就是a
//	printf("%d\n", a);
//	printf("%d", sizeof(int*));//指针大小在32位电脑是4个字节，在64位电脑是8个字节
//	return 0;
//}



//利用宏来比较两个数的大小
//通常比较大小我们用定义函数的方法如：
//int MAX(int x, int y)
//{
//	if (x > y)
//		return x;          然后在主函数中使用定义的函数来比较两数大小，此外用宏的办法也可以解决
//	else 
//		return y;
//}

//#define MAX(X,Y) (X>Y?X:Y)  //宏的定义都是大写，后面的括号内即是宏的内容,相较于定义函数的方法较简便，只有一行，且不用规定类型
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int max;
//	max = MAX(a, b);
//	printf("max=%d", max);
//	return 0;
//}



//static关键字
//修饰局部变量，局部变量生命周期变长
//修饰全局变量，改变了全局变量的作用域---让静态的全局变量只能在自己所在的源文件内部使用，无法在其他源文件中使用extern声明后使用
//修饰函数，若修饰的函数在其他的源文件中，则无法使用，与全局变量相似。
//         普通的函数具有外部链接属性，被static修饰后外部连接属性变成内部链接属性
//void test()//用void创建的函数无返回值
//{
//	/*int a = 1;*/
//	static int a = 1;//static使得a成为一个静态的局部变量，只初始化一次，跳出作用域后不被销毁，再次进入函数时保留上一次的值
//	                 //程序执行一次过后不再执行
//	a++;
//	printf("a=%d\n", a);
//}
//int main()
//{
//	int i = 0;
//	while (i < 5)
//	{
//		test();
//		i++;
//	}
//	return 0;   //整个程序运行下来得到的输出是五个a=2，因为每次运行到test()时进入创建的函数a都会重新生成，a是局部变量只在作用域内有效
//}               //如果在int a = 1；前加上static，a就变成静态的，每次循环后还是原来的a，不会重新生成  



//typedef---类型定义/类型重定义
//int main()
//{
//	typedef unsigned int u_int;//将unsigned int这个关键字重新取名为u_int，二者是一样的
//	unsigned int a = 1;//unsigned为无符号整型
//	u_int b = 2;//a的类型和b的类型完全相同
//	printf("%d", a);
//	return 0;
//}


//exp1 ? exp2 : exp3  条件操作符（三目操作符）
//exp为某一条式子  该操作符的意思是若exp1为真，执行exp2的结果，若exp1为假，执行exp3的结果
//int main()
//{
//	int a = 3;
//	int b = 2;
//	int max = (a > b ? a : b);//若a>b为真，执行a，若a>b为假，执行b 
//	printf("%d", max);
//	return 0;
//}


//// && - 逻辑与操作符
//// || - 逻辑或操作符
//int main()
//{
//	//int a = 5;
//	//int b = 3;
//	//int c = a && b;//c语言中 0为假，非0为真，此例中a=5非0为真，b=3非0为真，&&是取交集（与）的意思 真交真为真
//	// 若a=0则为假，假交真为假，所以c=0
//	//printf("c=%d", c);//所以c为真=1
//	int a = 0;
//	int b = 3;
//	int c = a || b;// ||是取并集（或）的意思，a，b其中有一个为真，那么a||b为真，c=1
//	printf("c=%d", c);
//	return 0;
//}




////（类型）强制类型转换操作符
//int main()
//{
//	//int a = 3.14;//3.14是double类型，而a为int类型,会出现错误，故使用强制类型转换符
//	int a = (int)3.14;/制转换成整型
//	printf("a=%d", a);
//	return
////++，--操作符的使用
//int main()
//{
//	int a = 10;
//	//int b = a++;//后置++，先使用值再++，即b=10后a再+1为11	
//	//int b = ++a;//前置++，先++再赋值，即b=11,a=11
//	int b =a--;//后置--，先使用值再--，即b=10后a再-1为9
//	int b = --a;//前置--，先--再赋值，即b=9，a=9
//	printf("a=%d b=%d\n", a, b);
//	return 0;
// }



//~   按2进制位取反
//int main()
//{
//	int a = 2;
//	int b;
//	b = ~a;//如010按二进制取反为101
//	//此处涉及原码，反码，补码 。反码=原码按二进制位取反   补码=反码+1
//	//如：0的二进制位为00000000000000000000000000000000，二进制最高位代表符号，0为正，1为负
//	// 负数在内存中储存的时候，存储的是二进制的补码
//	//~0二进制为：11111111111111111111111111111111，该数第一位为1是负数，在电脑中存储为补码
//	//原码变补码过程：
//	//补码-1变反码：11111111111111111111111111111111 - 1 =11111111111111111111111111111110
//	//反码取反变原码，最高位代表符号不变：10000000000000000000000000000001，故~0=-1
//  //更快捷方法：原码变补码：从右往左找到第一个1，这个1的左边按数值位取反。补码变原码操作相同，从右往左找到第一个1，1的左边按数值位取反
//	printf("%d\n", b);
//}


//比较两数中较大的数
// if语句比较法
//int main()
//{
//	int a, b;
//	scanf("a=%d\nb=%d", &a, &b);
//	//printf("a=%d\nb=%d\n", a, b);
//	if (a > b)
//	{
//		printf("max=%d", a);
//	}
//	else
//		printf("max=%d", b);
//	return 0;
//}

//函数法
//int MAX(int a,int b)
//{
//	if (a > b)
//		return a;
//	else
//		return b;
//}
//int main()
//{
//	int a, b,max;
//	scanf("a=%d\nb=%d", &a, &b);
//	max = MAX(a, b);
//	printf("max=%d", max);
//}