#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//函数指针数组：存放函数指针的数组
int Add(int x, int y)
{
	return x + y;
}int Sub(int x, int y)
{
	return x - y;
}int Mul(int x, int y)
{
	return x * y;
}int Div(int x, int y)
{
	return x / y;
}
int main()
{
	int(*parr[4])(int, int) = { Add,Sub,Mul,Div }; //parr先与[]结合形成数组，数组每个元素的类型是int(*)(int,int)，这是一个函数指针
	//                                               所以parr是一个函数指针数组
	for (int i = 0; i < 4; i++)
	{
		printf("%d\n", parr[i](4, 2));//6,2,8,2
	}
	return 0;
}




//函数指针--指向函数的指针

//例2：解释下面代码
//void(*signal(int, void(*)(int)))(int);
//signal是一个函数声明
//signal函数的两个参数类型是int，函数指针，该函数指针指向的函数参数为int，返回类型是void
//signal的返回类型是void(*)(int)，也是一个函数指针，该函数指针指向的函数参数为int，返回类型是void
//我们可以用typedef来简化这行代码
//typedef void(*pfun)(int); //注意，平时我们重定义类型名时是typedef unsigned int uint; 把重定义后的类型名uint写在要重定义的类型名unsigned int后
//           //但对于函数指针来说，重定义后的名字是和函数指针的名字一样写在类型内的，不能写成typedef void(*)(int) pfun; 必须要和*写在一起
//pfun signal(int, pfun);



//例1：
//void Print(char* str) //写一个打印字符串的函数Print
//{
//	printf("%s", str);
//}
//int main()
//{
//	void(*p)(char*) = Print;//用p来接收函数Print的地址，返回类型是void，所以*p前也是void
//	(*p)("hello world"); //通过函数指针p来调用Print函数，先调用:(*p),再传参：("hello world")，这里可以直接传字符串，因为字符串的传参传的是首元素的地址
//	return 0;
//}



//int Add(int x, int y)
//{
//	return x + y;
//}
//int main()
//{
//	printf("%p\n", &Add);//打印出来有结果，说明函数也有地址
//	printf("%p\n", Add);//这里打印出来的结果与取地址函数的结果是一样的，说明函数名和&函数名都是函数的地址
//	//既然函数有地址，那么就可以用指针来接收它
//	//p=&Add
//	// 那函数指针p的类型又是什么？
//	//int* p(int,int)=&Add;  这样的写法是错误的，因为这样会被误认为p是一个函数：p后面有括号，说明p是一个函数，函数返回的类型是int*
//	//如果我们不想让p被误解为函数，那用括号把p和*号结合起来就可以让电脑明白p是一个指针了
//	int(*p)(int, int) = &Add;//Add
//	printf("%d\n", (*p)(3, 2));//解引用指针就能使用函数Add了
//	printf("%d\n", (**p)(3, 2)); //我们多加几颗*后打印会发现，无论是**还是***都不影响我们得出最终的结果，说明*号在这里没有什么用
//	printf("%d\n", (***p)(3, 2)); 
//	printf("%d\n", (p)(3, 2));//那我们就去掉*号再打印一次，发现结果还是一样的，那么这里**和***都是多此一举了，只讨论pa和*pa这两种情况
//                        出现这样的结果是因为打印Add函数地址时，Add和&Add结果相同，都表示函数Add的地址
//           int(*p)(int, int) = &Add;    *p可以理解成把Add的地址放入p中，解引用得到Add函数。
//                                      因为&Add和Add相同，那么*p和p自然也就没有区别  
//	return 0;
//}




//二维数组传参

//test(int arr[3][5])  //这是最中规中矩的二维数组传参方法，是可以的
//{}

//test(int arr[][5])   //这里传参时省略了二维数组的行，是可以的
//{}

//test(int arr[3][])   //这里传参时省略了二维数组的列，是不可以的
//{}

//test(int arr[][])     //这里传参时省略了二维数组的行和列，也是不可以的
//{}
//    以上可知，二维数组传参时行可以省略，列一定不能省略

//用指针接收二维数组传参
//test(int(*arr)[5])//这是指针接收二维数组传参的正确方法，因为二维数组名传参代表首元素地址，二维数组的首元素是一个数组，数组有5个元素，数组的地址就是数组指针
//{}                    //所以这里用指针接收二维数组参数时要使用数组指针的类型，使用一级指针或者二级指针都是错误的
//int main()
//{
//	int arr[3][5];
//	test(arr);
//	return 0;
//}





//指针的传参
//void test(int arr[])//用数组的形式来接收参数，传参一维数组不表明数组内有多少个元素是可以的
//{}
//void test(int arr[10])//如果要表明数组内有多少个元素也可以，因为不标都行，写错都没关系
//{}
//void test(int* arr)//传参时一维数组传的是首元素的地址，所以这里用一个指针来接收也可以
//{}
//void test2(int* arr[20])//指针数组也是数组，跟整型数组类似，只不过元素从整型变为指针，一样是用数组的形式来接收，同样，这里的20也可以省略
//{}
//void test2(int **arr)//这里用二级指针来接收，因为传参是首元素地址，指针数组的首元素是一级指针，一级指针的地址就是二级指针，这样写也没有问题
//{}
////以上函数传惨方式都没有问题
//int main()
//{
//	int arr1[10] = { 0 };//整型数组
//	int* arr2[20] = { 0 };//指针数组
//	test(arr1);
//	test2(arr2);
//	return 0;
//}



//int main()
//{
//	//复习
//	//字符指针
//	char ch = 'w';
//	char* p = &ch;
//	const char* p2 = "abcdef";//此处的"abcdef"是一个常量字符串，不能被修改，所以最好指针赋值的时候左边加一个const，使字符串不能通过*p修改
//	                         //另外，字符串直接赋给指针变量，其实指针指向的内容是字符串的首元素地址
//	//指针数组
//	int* arr[10];  //[]的优先级高于*，所以arr先与[]结合，表示数组，然后数组里的每个元素的类型是int*，也就是指针，所以是指针数组
//	char* ch[5];  //同上
//	//数组指针
//	int arr2[10];
//	int(*p)[10] = &arr2;//*p被括号括起来代表p与*先结合代表p是一个指针，然后再与[]结合，说明指向的是一个数组，数组里的元素的类型为int
//	//一般来说，去掉变量名就是变量的类型，数组指针的名字为p，所以去掉p后该数组指针的类型就是 int(*)[10]
//	return 0;
//}