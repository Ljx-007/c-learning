#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//命令行编译
//命令行编译就是在一个程序中不定义某个参数的值，而是在命令行进行gcc编译的时候给其赋值。
//例如，某个程序中有一个参数SZ并未赋值，在执行这个程序时，我们就可以在命令提示符里用命令来给参数SZ赋值，如：gcc -D SZ=20 test.c ，就是编译test.c的同时给SZ赋值
//执行的过程中电脑就会对程序中的SZ进行替换。
//当我们想用同一个程序在编译时达到不同效果的时候，命令行编译就能起到作用


//条件编译 -- 在编译一个程序的时候可以放弃一条或者一组语句
//条件编译一般用于调试性的代码，删除可惜，保留又碍事，所以我们可以选择性编译

//#ifdef
//#define DEBUG
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (int i = 0; i < 10; i++)
//	{
//		arr[i] = 0;
//#ifdef DEBUG   //如果定义了DEBUG，那么就执行下面的内容，如果没定义，就不执行
//		printf("%d ", arr[i]); //这是一条调试性的代码，用来看看数组arr的内容是否被更改为0了，这行代码实际上无关紧要，但调试的时候又需要，这时可以用到条件编译
//#endif  //用来结束#ifdef，与#ifdef配套
//	}
//	return 0;
//}

//#if+常量表达式
//表达式为真，则执行代码，为假则不执行
//int main()
//{
//		int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (int i = 0; i < 10; i++)
//	{
//		arr[i] = 0;
//#if 1-1  //#if后面的常量表达式为1-1=0，为假，那么就不执行下面的语句
//		printf("%d ", arr[i]); 
//#endif //用来结束#if
//	}
//	return 0;
//}


//多分支条件编译：
//#if + 常量表达式
//#elif + 常量表达式
//#else
//#endif 结尾
//如果#if为真，则执行#if下的语句，为假则判断#elif，#elif也为假的话就执行#else下的代码
//int main()
//{
//#if 1==0  //条件为假，不执行haha
//	printf("haha");
//#elif 1==2  //条件为假，不执行hehe
//	printf("hehe");
//#else  //前两个都为假，只能执行else
//	printf("heihei");
//#endif
//	return 0;
//}


//判断是否被定义
//#if defined(symbol)  --  如果symbol被定义过，那么执行下面语句，没被定义过则不执行，等价于#ifdef symbol
//#if !define(symbol)  --  如果symbol没被定义，那么执行下面语句，定义过则不执行，等价于#ifndef symbol
//int main()
//{
//#if defined(DEBUG)  //如果定义了DEBUG，则执行语句，等价于#ifdef DEBUG
//	printf("haha");
//#endif
//
//#if !defined(DEBUG)  //如果没定义DEBUG，则执行语句，等价于#ifndef DEBUG
//	printf("hehe");
//#endif
//	return 0;
//}
//嵌套指令 -- #if 中还有#if

//文件包含--#include
//如果包含本地文件，可以使用""来包含
//如果包含库文件，则使用<>来包含
//""和<>的搜索原理不同
//""是先在源文件所在的目录下搜索，如果找不到对应的头文件，则在电脑存放库文件的目录下搜索，如果也找不到，则报错
//<>是直接在电脑存放库文件的目录下搜索，如果找不到，则报错
//库文件也可以用""来包含，但是效率会相对低，因为库文件肯定是放在库文件目录下，而不是源文件所在的目录下，使用""就会先搜索一下源文件所在目录，这是没必要的，故效率低

//文件的嵌套包含
//在实际应用中，程序员A所写的代码包含了头文件xxx.h，程序员B所写的代码也包含了头文件xxx.h
//程序员C写代码时使用了程序员A,B的代码，那么程序员C的代码就引用了两次头文件xxx.h，当xxx.h的代码足够多时，引用两次xxx.h的代码在预编译时所要花费的时间将会很多
//为了解决同一个文件重复引用的情况，我们可以用条件编译来解决
//在每个头文件的开头写上这样的代码，就可以避免同一个文件重复引用

#ifndef __TEST_H__  //如果没有定义_TEST_H__
#define __TEST_H__  //则定义__TEST_H__
//头文件内容
#endif  //当有重复的头文件引用时，因为第一次引用该头文件时符号__TEST_H__已经被定义了，所以第二次#ifndef判断时就进不去了，最终达到头文件只包含一次的效果
//另外还可以使用#pragma once指令来代替上述代码
#pragma once  //代表当多个重复头文件引用时，只会引用一次


//在之前提到offsetof宏是用来判断结构体成员变量的偏移量的
//使用offsetof要引用头文件<stddef.h>
#include<stddef.h>
struct S
{
	char c1; //偏移量为0
	int i;  //偏移量为4
	char c2;  //偏移量为8
	//一共占了9个字节空间
};
//模拟实现宏offsetof
//首先了解offsetof是如何实现的，offsetof宏是用来判断结构体成员变量的偏移量的
//结构体中的第一个成员变量偏移量为0，后面的成员的偏移量则是成员的地址减去第一个成员的地址
//在结构体中，成员变量的地址相减得到的是两个成员中间的地址个数，也就是字节个数（一个地址占一个字节）
//那么其他成员变量的地址减去第一个成员变量的地址就是他们的偏移量，但如果不初始化一个结构体，我们无法得到第一个成员变量的地址
//    offsetof可以不初始化一个结构体而得到其成员变量的地址，所以我们要想办法实现这样的功能
//如果我们把第一个成员变量的地址设为0，那么第一个成员变量的偏移量自然为0，其他成员变量的地址减去第一个成员变量的地址（也就是0）就是偏移量
//由于偏移量是一个整型，所以相减得到的结果还要强制类型转换为int，所以其他成员变量的地址强制转换为int型后就是其偏移量
//所以我们把0强制类型转化为结构体指针，那么结构体的地址，也就是第一个成员变量的地址也就为0了
#define OFFSETOF(struct_name,member_name) (int)&(((struct_name*)0)->member_name)
int main()
{
	printf("%d\n", OFFSETOF(struct S, c1));
	printf("%d\n", OFFSETOF(struct S, i));
	printf("%d\n", OFFSETOF(struct S, c2));
	return 0;
}