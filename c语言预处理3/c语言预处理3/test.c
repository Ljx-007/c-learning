#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//上节讲到预处理符号，#define的使用，#和##

//带副作用的宏参数
//当宏参数在宏的定义中出现超过一次时，如果参数带有副作用，那么你在使用这个宏时就可能出现危险，导致不可预测的后果。
//副作用就是在表达式求值的时候出现的永久性的效果。例如：
//x+1; x本身的值并没有改变
//++x; x的值发生了永久性的改变

//例：定义一个宏比较两数大小
#define MAX(X,Y) ((X)>(Y)?(X):(Y)) //三目运算符，？前面的式子结果为真，则输出X，为假输出Y
//int main()
//{
//	int a = 10, b = 11;
//	int max = MAX(a++,b++);
	//输出结果为12，11，13而不是预想的11，11，12。这是因为宏参数不是传值而是替换
	//替换结果为：int max=( (a++) > (b++) ? (a++) : (b++) )
	//替换后先对(a++)>(b++)进行判断，后置++是先使用值再++，所以比较时a，b还没有++
	//判断出结果后，a，b各自++，值变为了11，12，判断完后就要输出内容了，因为判断结果为假，所以输出b++
	//输出时是b的后置++，所以还是先使用再++，于是输出b值12赋到max中，max=12，b又一次++变为13
	//所以最终输出结果为12，11，13
	//错误的原因就是宏的参数a++，b++具有副作用
//	printf("%d\n", max); //12
//	printf("%d\n", a);//11
//	printf("%d\n", b);//13
//	return 0;
//}

//宏和函数对比
//上述代码看似用函数也能实现，那么二者有什么区别呢？

//宏的优势：
//1.函数的使用有类型的要求，返回类型和参数类型都有要求。而宏与类型无关
//2.函数的调用和返回需要时间（使用的汇编代码更多），有可能调用和返回的时间加起来比函数实际上执行功能的时间还要多。而宏不需要调用和返回，在规模和速度上更胜一筹

//当然，宏相较于函数也有劣势
//1.每次使用宏时，一份宏定义的代码会插入到程序中，除非宏比较短，否则可能会大幅度增加程序的长度
//2.宏无法调试，调试是已经经过了编译和链接的阶段，到了执行的阶段了，而宏的替换在编译环节的预编译就已经进行了，所以宏无法调试
//3.宏与类型无关，不做类型检查，不够严谨，容易出现问题
//4.宏可能会带来运算优先级的问题，导致程序出错
//5.宏的参数可能会有副作用

//宏有时候可以做到函数做不到的事情，例如，因为宏与类型无关，所以宏的参数可以是类型，而函数的参数绝无可能是类型
#define SIZEOF(type) sizeof(type)
//有时我们使用malloc时，总是要先计算开辟的空间大小，并且进行强制类型转换，如：(int*)malloc(10*sizeof(int))
//我们可以使用宏定义，来把malloc的使用更加简化，如下所示
#define MALLOC(num,type) (type*)malloc(num*sizeof(type))
//int main()
//{
//	int* p = MALLOC(10, int);//这样，我们就可以很方便的把想要开辟的空间大小，和开辟出来内存的指针类型定义好了
//	printf("%d", SIZEOF(int));//此时宏的参数就是类型
//	return 0;
//}

//另外，#undef这条指令用于移除一个宏定义
#define MAX 100
int main()
{
	printf("%d\n", MAX);
#undef MAX 
	printf("%d", MAX); //此时MAX的定义已经被取消了
	return 0;
}