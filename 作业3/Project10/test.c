#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
//练习5：找出杀人犯。
//A：不是我	   B:是C    C：是D    D：C在胡说
//已知三个人说了真话一个人说了假话，用编程找出凶手
//int main()
//{
//	//设说真话为1，说假话为0
//	int killer = 0;
//	for (killer = 'a'; killer <= 'd'; killer++)
//	{
//		if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3)
//			//三个人说了真话，一个人说了假话，所以有三个1一个0，四个人说话的布尔值相加为3
//			//假设凶手遍历a，b，c，d，如果出现四个条件布尔值相加为3，则说明凶手就是正在遍历的那个值
//		{
//			printf("killer=%c", killer);
//		}
//	}
//	return 0;
//}




//练习4：打印杨辉三角
//1
//1 1
//1 2 1
//1 3 3 1
//........


//方法二：（数组法） 占用资源较小
//int main()
//{
//	int arr[10][10] = { 0 };
//	int i = 0, j = 0;
//	for (i = 0; i < 10;i++)
//	{
//		for (j = 0; j < 10; j++)
//		{
//			if (j == 0)
//				arr[i][j] = 1;
//			if (i == j)
//				arr[i][j] = 1;
//			if (i > 1 && j >= 1)
//				arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j];
//		}
//	}
//	for (i = 0; i < 10; i++)
//	{
//		for (j = 0; j <= i; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}





//方法一：（函数法）
float Fac(int x)   //这里打印时要返回float类型，如果是int类型会溢出
{
	if (x == 0)
		return 1;
	else
	{
		float ret = 1;
		for (int i = 1; i <= x; i++)
		{
			ret *= i;
		}
		return ret;
	}
}
int Cmb(int n, int k)
{
	int  ret = 0;
	ret = Fac(n) / (Fac(n - k) * Fac(k));
	return ret;
}
int main()
{
	int n;
	printf("输入你想打印的杨辉三角的行数：");
	while (1)
	{
		scanf("%d", &n);
		if (n <= 0)
		{
			printf("不可以是负数\n");
		}
		else
			break;
	}
	for (int i = 0; i < n; i++)
	{
		for (int k = n-i-1; k > 0; k--)
		{
			printf("   ");
		}
		for (int j = 0; j <= i; j++)
		{
			int ret = Cmb(i, j);
			printf("%6d",ret);//%6d是整数输出，宽度是6位，不足左边补空格，如果是%-6d的话就是右边补空格
		}
		printf("\n");
	}
	return 0;
}


//练习3：下述代码打印结果为？
//int main()
//{
//	char a[1000] = { 0 };
//	for (int i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//char类型的范围是-127到128，随着for循环的进行，a数组中的数字会变成-1，-2，-3，....，-128，127，126，....，3，2，1，0，-1，-2，-3...
//		//-128在内存中存储的二进制为1000 0000，-128-1在二进制中表示为1000 0000 - 0000 0001=0111 1111--127
//		//由于a是字符数组，也就是字符串，字符串识别到'\0'（数值上等于0）就会停止，a数组中0之后的数字不会再算入
//	}
//	//strlen这个函数则是识别字符串的长度，'\0'除外，所以a数组中真正存储的数字只有-1，-2，-3，....，-128，127，126，....，3，2，1，0
//	 //除0外剩下的长度就是128+127=255
//	printf("%d\n", strlen(a));//255
//	return 0;
//}



//练习2：下述变量b在32位大端模式处理器上变量b等于？
//int main()
//{
//	unsigned int a = 0x1234;
//	//16进制1位就等于2进制的4位，所以0x1234转换为二进制就是0001 0010 0011 0100
//	//unsigned int 类型能够存储4个字节32个bit位，而0x1234只占了2个字节16个bit位
//	//所以在小端模式处理器下，a在内存中的存储布局为：34 12 00 00
//	//在大端模式处理器下，a在内存中的存储布局为：00 00 12 34
//	unsigned int b = *(unsigned char*)&a;//a在取地址后被强制转换为unsigned char*类型，再解引用后只能访问一个字节
//	//所以在大端存储模式下，解引用后a中只有一个字节的数存到了b中，那就是00，所以b在内存中的布局为：00 00 00 00 
//	//0x00转换为十进制数字就是0
//	printf("%d", b);//由于我们的计算机是小端存储，所以跑出来是52不是0
//	return 0;
//}



//练习1：下列代码输出结果为？
//int main()
//{
//	unsigned char a = 200;//1100 1000
//	unsigned char b = 100;//0110 0100
//	unsigned char c = 0;//我们知道char类型的范围是-128->127，unsigned char的范围是0-255
//	c = a + b; //a+b作整型运算，所以要整型提升
//	//a整型提升后：0000 0000 0000 0000 0000 0000 1100 1000
//	//b整型提升后：0000 0000 0000 0000 0000 0000 0110 0100
//	//  a+b=300 -> 0000 0000 0000 0000 0000 0001 0010 1100 
//	//c的类型也是unsigned char，只能存放8个bit，所以发生截断：0010 1100 --44
//	//%d打印整型，a+b整型提升后就是一个整型，所以直接打印整型提升后的结果，就是300
//	//%d打印c，要求打印整型所以c截断后也要整型提升，c是无符号数，整型提升补0，就是0000 0000 0000 0000 0000 0000 0010 1100 --44
//	printf("%d %d", a + b, c);//300，44
//	return 0;
//}