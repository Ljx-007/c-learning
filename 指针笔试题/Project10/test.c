#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//试题2
int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRST" }; //c是一个数组，数组元素的类型为char*，分别是四个字符串首元素地址
	char** cp[] = { c + 3,c + 2,c + 1,c };//cp是一个数组，数组元素类型为char**，c是一个数组名，本身是一个指针，指针指向的数组内还有地址，所以c是一个二级指针
	char*** cpp = cp;//cp是一个数组名，指向的数组含有二级指针，所以cp是一个三级指针，这里用三级指针cpp接收cp
	printf("%s\n", **++cpp);//++优先级高，先运算++，cpp等于cp，除了sizeof和&外数组名代表首元素地址，所以++cpp后指向的是cp数组中的c+2
	                        //于是第一次解引用得到c+2，c+2是一个二级指针，指向的是"POINT"这个字符串的首元素地址
	                       //解引用后得到其地址以%s形式打印出来就得到POINT
	printf("%s\n", *--*++cpp + 3);//这里注意，cpp在上一次的打印中已经自增过一次，所以第二次打印前cpp指向的是cp数组中的c+2
	                   //++优先级高，运算++后指向的是cp数组中的c+1，解引用后得到c+1，在运算--，c+1减减后是c，c是数组名，指向的是首元素地址，首元素为字符串"ENTER"
	                //再次解引用后得到首元素"ENTER"中E的地址，+3后指向第二个E，于是打印出来的结果为ER
	printf("%s\n", *cpp[-2]+3);//经过前两次打印cpp自增后指向c+1，[]的优先级高，此前，我们讲过p[i]==*(p+i),所以这里cpp[-2]就等于*(cpp-2)
	                    //cpp-2后指向cp数组中的c+3，c+3指向字符串"FIRST"中F的地址，解引用后得到F的地址，+3跳过三个字符指向S
	                   //所以打印结果为ST
	printf("%s\n", cpp[-1][-1] + 1);//cpp经过前两次打印自增指向c+1，cpp[-1]=*(cpp-1),cpp-1指向c+2，解引用得到c+2，式子就变成(c+2)[-1]+1
	                            //(c+2)[-1]==*(c+2-1)==*(c+1)，c+1指向的是"NEW"这个字符串中N的地址，解引用得到N的地址，再+1跳过1个字符指向E
	                        //最后的打印结果为EW
	return 0;
}


//试题1，下列输出的结果为？
//int main()
//{
//	//之前讲过可以用char* p="abcdef"，用一个指针来表示一个字符串，这个指针指向的是字符串的首元素地址
//	char* a[] = { "work","at","alibaba" };//a是一个数组，数组元素的类型为char*，所以a是一个装有字符'w','a','a'这三个字符串的首元素地址的数组
//	char** pa = a;//数组名本身是一个地址，数组的元素也是一个地址，所以可以用二级指针pa来表示a，也就是说a本身就是一个二级指针
//	pa++;//如int* p;p+1跳过的是一个整型，因为*代表p是一个指针，前面的int代表指向的是一个整型，此处char** pa也类似
//	 //char* *pa,第二颗*代表pa是一个指针，指向的类型是char*，所以pa++时跳过的也是一个char*类型，所以此时pa++后指向的是第二个字符串的首元素地址
//	//也就是说，a数组中有三个char*类型的地址，分别指向的是这三个字符串的首元素地址'w','a','a'，pa++跳过了w后指向的就是第二个'a'的地址
//	printf("%s\n", *pa);//此时解引用pa后得到的就是"at"中'a'的地址，再以字符串形式打印得到的就是at
//	return 0;
//}