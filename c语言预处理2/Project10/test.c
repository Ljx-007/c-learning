#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//上节讲到翻译环境过程
//翻译过程有编译和链接
//编译分为预编译，编译，汇编
//在Linux环境下汇编生成 .o文件，.o文件经过链接器进行链接，最后生成可执行文件
//上节详细讲了编译的过程，这节讲链接

//链接：
//1.合并段表：生成目标文件后，把多个目标文件合并在一起，目标文件中有不同的数据段，合并段表就是把处在目标文件相同位置的数据段合并在一起
//2.符号表的合并和重定位：在汇编过程形成的符号表，不同源文件有各自的符号表，链接阶段进行符号表的合并，如果符号重复，则取具有有效地址的符号进行合并
//至此翻译环境结束

//运行环境
//1.程序执行时载入内存中，有操作系统的话就由操作系统来完成，没有就必须手工安排，也可能是通过可执行代码置入只读内存来完成
//2.程序的执行开始，首先调用main函数
//3.执行程序时，会使用一个运行时堆栈，存放局部变量，返回地址。同时也可以使用静态内存，存储于静态内存的变量在程序执行过程中可以一直保留他们的值
//4.终止程序，可能正常结束也可能意外结束
//到此程序从源代码到执行的过程已经笼统的介绍完了，接下来详细介绍预处理阶段的过程


//预处理详解：

//预定义符号：已经帮我们定义好的符号，可以直接拿来用
//__FILE__      --  当前代码文件所在的绝对路径
//__LINE__      --  代码所在的行号
//__DATE__      --  当前日期
//__TIME__      --  当前时间
//__FUNCTION__  --  所在函数的函数名
//__STDC__      --  C语言标准规定,__STDC__被定义为1，但在VS中并没有定义
//这些预定义的符号可以帮助我们写日志文件
//int main()
//{
//	printf("%s\n", __FILE__);//__FILE__就是当前代码文件所在的绝对路径
//	printf("%d\n", __LINE__);//代码所在的行号
//	printf("%s\n", __DATE__); //当前日期
//	printf("%s\n", __TIME__);//当前时间
//	//写日志文件
//	int arr[10] = { 0 };
//	FILE* pf = fopen("log.txt", "w"); //创建一个日志文件，将操作的路径，行号，日期和时间都放进去
//	for (int i = 0; i < 10; i++)
//	{
//		arr[i] = i;
//		fprintf(pf, "file:%s  line:%d  date:%s  time:%s  i=%d\n", __FILE__, __LINE__, __DATE__, __TIME__, i);
//	}
//	fclose(pf), pf = NULL;
//	return 0;
//}


//预处理指令：
//#define ,#include ,#pragma, #if ,#endif , #ifdef ,#line 等都是预处理指令

//#define  --  可以定义标识符，也可以定义宏
//#define可以定义各种符号，可以给某个符号定义一个数，也可以给符号定义一个字符串，也可以给关键字重命名
//例：
#define MAX 100  //给MAX定义为一个数：100
#define STR "hehe"  //给STR定义为字符串hehe
#define reg register  //为register创建一个简单的名字
#define do_forever for(;;)  // 用更形象的符号来代替死循环的实现
#define CASE break;case    //在写case语句后自动把break加上
//#define甚至可以定义一段代码，如果定义的东西过长，可以分成几行写，除了最后一行外，每一行都要加上一个反斜杠（续行符）
#define DEBUG_PRINT printf("file:%s\tline:%d\t\
							date:%s\ttime:%s\n",\
							__FILE__,__LINE__,\
							__DATE__,__TIME__)   


//#define定义宏
//#define允许把参数替换到文本中，这种实现通常称为宏或者定义宏
//宏的申明,例：
#define SQUARE(X) X*X
//int main()
//{
//	int ret = SQUARE(5);//宏计算时并不是传参，而是替换，这里是把X替换为5
	//计算int ret =SQUARE(5+1)时，得到的结果并不是36，而是11，这是因为宏计算时替换的是括号里的内容，而不是先计算好括号里的内容再替换
	//所以替换得到的式子是  5+1*5+1=11 ，如果要得到36的结果，那么就得给X加上括号，让5+1的加法优先计算
	//即#define SQUARE(X) (X)*(X) ,所以为了避免不必要的错误，在使用宏时不要吝啬括号
//	printf("%d", ret);
//	return 0;
//}
//总结：用于对数值表达式进行求值的宏定义，都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用
//注意：1.宏参数和#define定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归
 //     2.当预处理器搜索#define定义的符号时，字符串常量的内容并不被搜索，例如printf("MAX=%d",MAX) ,第一个MAX属于字符串中的内容，所以不会替换，第二个MAX才会替换

//补充：相邻字符串具有自动连接特点
//int main()
//{
//	printf("hello world");
//	printf("hello" " world"); //第二个printf中把hello 和world分成了两个字符串，但是打印出来的结果却和第一个print相同，说明相邻的字符串会自动连接
//	return 0;  
//}

//得到相邻的字符串会自动连接这个结果之后，再来探讨一个问题
//如果创建一个函数print，达到这样一种效果
// int a=10,b=20;
//print(a) 输出  the value of a is 10
//print(b) 输出  the value of b is 20
//想要达到这样的效果，那么就要创建一个这样的函数
void print(int x)
{
	printf("the value of x is %d\n", x);
}
//但是经过实操后发现并不能做到改变参数的同时改变字符串的内容，所以函数是不能达到我们想要的效果的
//那宏可以吗？
// #define PRINT(X) printf("the value of X is %d",X)
//实操后发现这样定义宏也不能达到想要的效果，字符串里的X并没有变化。在宏中使用#可以完美的实现我们想要的效果

//#和##
#define PRINT(X) printf("the value of "#X" is %d\n",X)
//已知相邻的字符串会自动连接，所以可以大胆的将the value of 和is %d\n分开，变成两个字符串
//给中间的X前加一个#，那么预处理时加了#的X就不会被替换，而是会变成字符串X，所以#X的意思就是：所要替换的值的名字的字符串（替换为变量名的字符串而不赋值）
//int main()
//{
//	int a = 10, b = 20;
//	PRINT(a);
//	PRINT(b);  //实践后，可以知道，#将要替换掉的X变成了字符串，并且更改为其值的变量名，实现了将参数插入到字符串中的功能
//	//再因为相邻字符串的自动连接性，于是达到了想要的效果
//	return 0;
//}

// ##：##在宏的使用中是把两个符号合并成一个符号
//例如：
#define CAT(X,Y) X##Y   ///在CAT这个宏中，用##把符号X和符号Y合并在一起
int main()
{
	int hello12 = 10;
	printf("%d", CAT(hello, 12)); //在CAT这个宏中，hello和12被##合并在一起变成hello12 ，hello12的值为10，所以打印出来就是10
	return 0;
}