#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
//练习2：杨氏矩阵
//杨氏矩阵：矩阵的每行从左到右递增，矩阵每列从上到下是递增的，请编写程序在这样的矩阵中查找某个数字是否存在
//要求：时间复杂度小于O(N)
//时间复杂度O(N)的意思是，如果一个数组有N个元素，要从数组中找某个元素，从前往后遍历这个数组，最坏的情况是找N次才能找到这个元素
//所以遍历数组来查找元素的时间复杂度就是O(N)，这里要求时间复杂度小于O(N)，就说明不能遍历这个数组
int Findnum(int arr[3][3], int k, int* px, int* py)
{
	//首先找到数组右上角的数字
	int x = 0;
	int y = *py - 1;
	while (x <= *px && y >= 0)  //这里先把*px和*py当作行和列来用
	{
		if (k > arr[x][y])
			x++;
		else if (k < arr[x][y])
			y--;
		else
		{
			*px = x; //最后找到数字后把*px和*py改成x和y的值，主函数中的x，y就能代表下标了
			*py = y;
			return 1;
		}
	}
	return 0;
}
int main()
{
	int arr[3][3] = { {1,2,3},{2,3,4},{3,4,5} };
	int arr2[3][3] = { {1,2,3},{4,5,6},{7,8,9} };  //这里arr和arr2都是杨氏矩阵
	//这里介绍一种方法，以arr2为例，数组是这样的
	//1 2 3
	//4 5 6
	//7 8 9
	//右上角和左下角的数字比较特殊，以右上角为例，假设我们要查找7这个数字
	//先找到右上角的数字3，由于杨氏矩阵每行从左到右递增，每列从上到下递增，3是这一行最大的数字，这一列最小的数字
	//如果要查找的数字比3大，则说明这一行都没有要查找的数，可以排除
	//如果要查找的数字比3小，说明这一列都没有要查找的数，可以排除
	//所以判断右上角的数字与查找的数字大小比较可以直接去掉一行或者一列
	//排除完一行后数组变成了
	//4 5 6
	//7 8 9    继续找右上角的数字6，6比7小，说明7不在6这一行，可以去掉
	//去掉这一行数组变成了
	//7 8 9   这时右上角数字变成了9，9比7大，说明这一列都没有7
	//去掉这一列，数组变成了
	//7 8     右上角数字变成8，8比7大，所以8这一列没有7
	//最后去掉8这一列就剩下7了，7就是我们要查找的数
	int k =2;//要查找的数字
	int x = 3, y = 3;
	//这里找到了我们只能知道找到了而不知道这个数字的下标
    //原因是下标x，y在Findnum函数里，是局部变量。修改方法是把x，y从函数中拿出来，以地址的方式传进函数里，这样我们就能找到x，y了
	//这种设计方式就叫返回型参数，能把函数里的数字带回主函数
	//当我们用函数的返回值搞不定时，就可以用返回型参数的设计来解决
	int ret = Findnum(arr2, k, &x, &y); //封装一个函数，参数为数组名和要查找的数字和数组的行和列
	if (ret == 1)
		printf("找到了,下标是arr[%d][%d]\n",x,y);
	else
		printf("找不到\n");
	return 0;
}

	




//继上节课判断一个字符串是否由另一个字符串旋转的来的
//新方法：如果要左旋一个字符串"abcdef"
//那么左旋的左右结果为"bcdefa","cdefab","defabc","efabcd","fabcde"
//在原来的字符串"abcdef"上拼接一个一模一样的字符串"abcdef"，就变成了"abcdefabcdef"
//会发现左旋的所有结果都在这个拼接的字符串中可以找到，接下来就用编程来实现这样的方法
//这种方法比直接暴力循环求解来的更方便更快
//int is_leftmove(char* str1, char* str2)
//{
//	//在str1字符串中追加一个str1字符串
//	//然后判断str2指向的字符串是否是str1指向的字符串的子串
//	//追加字符串用strcat这个函数，用法为：strcat(str1,str2)，这代表在str1字符串的后面追加str2这个字符串
//	//如:char arr1[30]="abc" ,char arr2[]="def"
//	//  strcat(arr1,arr2)  这时候arr1就变成了abcdef
//	//注意，strcat是不能自己追加自己的，strcat(arr1,arr1)是错误写法
//	//因为strcat的原理是将str2的字符串一个一个追加到str1中。如上述例子arr2中的d替换掉arr1中的\0，剩下的ef\0也追加到arr1中
//	//如果是自己追加自己，arr1中的a就会替换掉arr1中的\0,bc追加到后面，但是\0已经被替换掉了，所以自己追加自己永远不会出现\0，会报错
//	//如果要自己追加自己，则使用strncat这个函数，strncat比strcat函数多了一个参数count，即要追加多少个字符，就与\0无关了
//	//这里我们str1追加str1，要使用strncat
//	int len = strlen(str1);
//	int len2 = strlen(str2);
//	if (len != len2)
//		return 0;    //如果str1和str2的字符长度不相同，那么str2肯定不是str1旋转的来的，所以在追加字符串之前就返回0
//	char* ret=strncat(str1, str1,len); //此时字符串ch变成"abcdefabcdef"
//	//追加完字符串后还要判断追加后的字符串中是否含有字符串str2，找子串我们用strstr函数
//	// strstr(str1,str2) 代表str1中是否含有str2字符串，如果有返回含有str1中str2字符串首元素的地址，无则返回NULL
//	//例如str1="abcdefabcdef",str2="cdefab", strstr(str1,str2),str1中含有str2，返回str1中c的地址
//	if (ret == NULL)
//		return 0;
//	else             //但使用这种方法有一个问题，就是假设ch2[]="cdef"，按照程序运行下来会返回yes，但是ch2却不是ch旋转得来的
//		return 1;           //所以我们还要保证str1和str2的长度相同
//}
//int main()
//{
//	char ch[30] = "abcdef";  //因为要追加字符串，所以这里的ch数组给了一个比较大的空间
//	char ch2[] = "cdefab";
//	int ret = is_leftmove(ch, ch2);
//	if (ret == 1)
//		printf("Yes\n");
//	else
//		printf("No\n");
//	return 0;
//}